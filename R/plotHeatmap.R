#' Generate a Heatmap Plot
#'
#' This function generates a heatmap using the CohortContrast GUI object.
#' It extracts necessary components from the ccObject and passes them to the
#' `createHeatmapPlot` function to generate the plot.
#'
#' @param ccObject An object returned by the CohortContrast GUI, typically created
#'        when the "Create Visual Snapshot" button is pressed. It should contain
#'        target_row_annotation, target_col_annotation, and target_matrix components.
#' @return A plot object generated by `createHeatmapPlot`.
#' @examples
#' \dontrun{
#' # Assuming `ccObject` (visual snapshot) is already created via CohortContrast GUI
#' ccObject <- readRDS("./visual_snapshots/CohortContrastDataVisualSnapshot.rds")
#' getHeatmapPlot(ccObject)
#' }
#' @export
getHeatmapPlot <- function(ccObject) {
  createHeatmapPlot(
    ccObject$filtered_target
  )
}

#' @keywords internal
createHeatmapPlot <- function(filtered_target, isCorrelationView = FALSE) {
  plot_data = getHeatmapPlotData(filtered_target, isCorrelationView = isCorrelationView)

  # Check if any concepts left
  if (is.null(plot_data)) {
    return(getErrorPlot("After filtering there are < 2 concepts left"))
  }

  if (isCorrelationView) {
    return(getHeatmapPlotCorrelation(plot_data))
  } else {
    return(getHeatmapPlotRegular(plot_data))
  }
}

#' @keywords internal
createHeatmapPlotaNoPatientDataAllowed <- function(data, isCorrelationView = FALSE, correlationThreshold = 0.95, abstractionLevel = -1) {
  plot_data = getHeatmapPlotDataNoPatientDataAllowed(dataPatients = data$data_patients, isCorrelationView = isCorrelationView, abstractionLevel = abstractionLevel)
  # Check if any concepts left
  if (is.null(plot_data)) {
    return(getErrorPlot())
  }

  if (isCorrelationView) {
    plot_data = prepare_heatmap_correlation_groups(heatmapData = plot_data, correlation_threshold = correlationThreshold)
    return(getHeatmapPlotCorrelationNoPatientDataAllowed(plot_data))
  } else {
    return(getHeatmapPlotRegularNoPatientDataAllowed(plot_data))
  }
}

#' @keywords internal
getHeatmapPlotData <- function(filtered_target, isCorrelationView = FALSE) {
  if (is.null(filtered_target) ||
      nrow(filtered_target$target_row_annotation) == 0) {
    return(NULL)
  }

  if (is.null(nrow(filtered_target$target_matrix))) {
    filtered_target$target_matrix <-
      t(as.matrix(filtered_target$target_matrix)[1:length(filtered_target$target_matrix), , drop = FALSE])
    rownames(filtered_target$target_matrix) <-
      rownames(filtered_target$target_row_annotation)
  }

  heatmapData = list()

  if (isCorrelationView) {

    ordered_matrix <- filtered_target$correlation_analysis$ordered_matrix
    gaps_row <- filtered_target$correlation_analysis$gaps_row

    # Compute row-wise clustering
    dist_matrix <- stats::as.dist(1 - stats::cor(t(ordered_matrix), method = "pearson", use = "pairwise.complete.obs"))
    hc_rows <- stats::hclust(dist_matrix)

    # Cut the dendrogram into clusters
    num_clusters <- length(gaps_row) + 1 # Define number of clusters based on gaps
    cluster_labels <- stats::cutree(hc_rows, k = num_clusters)

    #Returns
    heatmapData$ordered_matrix = ordered_matrix
    heatmapData$hc_rows = hc_rows
    heatmapData$num_clusters = num_clusters

  } else {

    filtered_target$target_row_annotation <-
      as.data.frame(filtered_target$target_row_annotation)
    filtered_target$target_col_annotation <-
      as.data.frame(filtered_target$target_col_annotation)
    rownames(filtered_target$target_col_annotation) <-
      filtered_target$target_col_annotation$PERSON_ID

    # Patient clustering
    col_clustering <-
      stats::hclust(stats::dist(t(filtered_target$target_matrix)))
    # Row reordering
    reordering <- filtered_target$target_row_annotation %>%
      tibble::rownames_to_column("CONCEPT_ID") %>%
      dplyr::group_by(.data$HERITAGE) %>%
      dplyr::arrange(dplyr::desc(.data$CONCEPT_NAME)) %>%
      dplyr::summarize(CONCEPT_ID = list(.data$CONCEPT_ID)) %>%
      dplyr::mutate(MATRIX = purrr::map(.data$CONCEPT_ID, ~ filtered_target$target_matrix[.x, , drop = F])) %>%
      dplyr::mutate(MATRIX = purrr::map(.data$MATRIX,
                                        function(x) {
                                          if (nrow(x) > 1) {
                                            x <- x[stats::hclust(stats::dist(x))$order, ]
                                          }

                                          return(x)
                                        }))
    tm <- as.data.frame(do.call(rbind, reordering$MATRIX))
    tm_gaps <- purrr::map_int(reordering$MATRIX, nrow) %>% cumsum()
    ordered_matrix <- as.matrix(tm)
    rownames(ordered_matrix) <-
      filtered_target$target_row_annotation[rownames(tm), ]$CONCEPT_NAME
    annotation_row <- filtered_target$target_row_annotation %>%
      dplyr::arrange(.data$CONCEPT_NAME) %>%
      tibble::remove_rownames() %>%
      tibble::column_to_rownames("CONCEPT_NAME") %>%
      dplyr::select(-.data$PREVALENCE_DIFFERENCE_RATIO)
    annotation_col <- filtered_target$target_col_annotation
    # Heritage colors pre-defined
    heritage_colors <- getHeritageColors(asList = TRUE)

    active_gender_colors <-
      c(
        Male = "purple",
        Female = "pink",
        Other = "lightblue"
      )

    # Filter heritage colors based on what's present in annotation_row
    active_heritage_colors <-
      heritage_colors[names(heritage_colors) %in% unique(annotation_row$HERITAGE)]
    active_gender_colors <-
      active_gender_colors[names(active_gender_colors) %in% unique(annotation_col$GENDER)]


    # Specify colors including a dynamic gradient for AGE
    annotation_colors <- list(
      AGE = colorRampPalette(c("lightblue", "firebrick"))(length(unique(
        annotation_col$AGE
      ))),
      GENDER = active_gender_colors,
      HERITAGE = active_heritage_colors,
      PREVALENCE = colorRampPalette(c("white", "purple"))(length(unique(
        annotation_row$PREVALENCE
      )))
    )

    # annotation_row
    annotation_row <- annotation_row %>%
      tibble::rownames_to_column("CONCEPT_NAME") %>%
      dplyr::arrange(.data$HERITAGE, dplyr::desc(toupper(.data$CONCEPT_NAME))) %>%
      tibble::column_to_rownames("CONCEPT_NAME")
    # Apply the same order to the matrix
    ordered_matrix <- ordered_matrix[rownames(annotation_row), ]

   if(is.null(rownames(ordered_matrix))){
     return(NULL)
   }
   rownames(ordered_matrix) <- unique_names(rownames(ordered_matrix))

    #Returns
    heatmapData$ordered_matrix = ordered_matrix
    heatmapData$annotation_row = annotation_row
    heatmapData$annotation_col = annotation_col
    heatmapData$annotation_colors = annotation_colors
    heatmapData$col_clustering = col_clustering
    heatmapData$tm_gaps = tm_gaps
    }

  return(heatmapData)
}


#' @keywords internal
getHeatmapPlotDataNoPatientDataAllowed <- function(dataPatients = NULL, isCorrelationView = FALSE, abstractionLevel = -1) {

  heatmapData = list()

  if (is.null(dataPatients) ||
      nrow(dataPatients) == 0) {
    return(NULL)
  }

  heatmapData <- computeConceptCorrelations(data_patients = dataPatients, autoScaleRate = FALSE, abstractionLevel = abstractionLevel)

  return(heatmapData)
}

#' @keywords internal
getHeatmapPlotRegular <- function(plot_data) {

  heatmap <- pheatmap::pheatmap(
    plot_data$ordered_matrix,
    show_colnames = FALSE,
    annotation_row = plot_data$annotation_row %>% dplyr::select(.data$HERITAGE),
    annotation_col = plot_data$annotation_col %>% dplyr::select(.data$AGE, .data$GENDER),
    annotation_colors = plot_data$annotation_colors,
    cluster_cols = plot_data$col_clustering,
    cluster_rows = FALSE,
    gaps_row = plot_data$tm_gaps,
    color = c("#e5f5f9", "#2ca25f"),
    legend_breaks = c(0.25, 0.75),
    legend_labels = c("Absent", "Present"),
    cellheight = 18,
  )
  return(heatmap)
}

#' @keywords internal
getHeatmapPlotCorrelation <- function(plot_data) {

  heatmap <- pheatmap::pheatmap(
    plot_data$ordered_matrix,
    cluster_rows = plot_data$hc_rows,            # Pass the row dendrogram
    cluster_cols = TRUE,               # Cluster columns
    cutree_rows = plot_data$num_clusters,        # Number of row clusters (defines gaps)
    show_colnames = FALSE,             # Hide column names
    color = c("#e5f5f9", "#2ca25f"),   # Custom colors
    treeheight_row = 50                # Height of the row dendrogram
  )
  return(heatmap)
}


#' @keywords internal
getHeatmapPlotRegularNoPatientDataAllowed <- function(plot_data) {

  if(is.null(plot_data$correlation_matrix) | is.null(plot_data$map)) {
    return(getErrorPlot())
  }

  concept_order <- data.frame(CONCEPT_ID = rownames(plot_data$correlation_matrix)) %>%
    dplyr::left_join(plot_data$map, by = "CONCEPT_ID")

  # Order by HERITAGE and sort within each group
  concept_order <- concept_order %>%
    dplyr::arrange(HERITAGE, dplyr::desc(toupper(CONCEPT_NAME)))

  # Extract ordered correlation matrix
  ordered_matrix <- plot_data$correlation_matrix[concept_order$CONCEPT_ID, concept_order$CONCEPT_ID]

  # Rename rownames with Concept Names instead of Concept IDs
  rownames(ordered_matrix) <- concept_order$CONCEPT_NAME

  # Identify row gaps based on HERITAGE transitions
  heritage_groups <- concept_order$HERITAGE
  tm_gaps <- which(diff(as.numeric(factor(heritage_groups))) != 0)

  # Prepare row annotations (HERITAGE-based facets)
  annotation_row <- concept_order %>%
    dplyr::select(CONCEPT_NAME, HERITAGE) %>%
    tibble::column_to_rownames("CONCEPT_NAME")

  # Convert heritage_colors dataframe to a named vector
  heritage_colors <- getHeritageColors()
  heritage_color_mapping <- stats::setNames(heritage_colors$color, heritage_colors$HERITAGE)

  # Filter only the relevant HERITAGE colors based on present groups
  active_heritage_colors <- heritage_color_mapping[names(heritage_color_mapping) %in% unique(annotation_row$HERITAGE)]

  # Define gradient color palette for correlation values, ensuring 0 is white
  heatmap_colors <- grDevices::colorRampPalette(c("lightblue", "white", "firebrick"))(100)

  # Define breakpoints so that the color gradient is centered at 0
  breaks <- seq(-1, 1, length.out = 101)  # Ensuring symmetric scaling

  # Define annotation colors using the filtered heritage colors
  annotation_colors <- list(
    HERITAGE = active_heritage_colors
  )

  heatmap <- pheatmap::pheatmap(
    ordered_matrix,
    cluster_rows = FALSE,         # No clustering of rows
    cluster_cols = FALSE,         # No clustering of columns
    show_colnames = FALSE,        # Hide column names
    annotation_row = annotation_row, # HERITAGE-based annotation
    annotation_colors = annotation_colors,
    gaps_row = tm_gaps,           # Insert gaps between HERITAGE groups
    color = heatmap_colors,       # Use continuous gradient
    breaks = breaks,              # Ensure proper scaling from -1 to 1
    legend = TRUE,                # Keep numerical correlation values in legend
    cellheight = 18,
    display_numbers = TRUE,
    number_color = "black"
  )
  return(heatmap)
}

#' @keywords internal
getHeatmapPlotCorrelationNoPatientDataAllowed <- function(plot_data) {

  # Extract ordered correlation matrix and row gaps
  ordered_matrix <- plot_data$correlation_analysis$ordered_matrix
  gaps_row <- plot_data$correlation_analysis$gaps_row

  # Extract concept mapping to replace IDs with names
  concept_map <- plot_data$map
  concept_ids <- rownames(ordered_matrix)

  # Match IDs with Concept Names
  concept_names <- concept_map %>%
    dplyr::filter(CONCEPT_ID %in% concept_ids) %>%
    dplyr::arrange(match(CONCEPT_ID, concept_ids)) %>%
    dplyr::pull(CONCEPT_NAME)

  # Rename row names with Concept Names
  rownames(ordered_matrix) <- concept_names

  # Compute hierarchical clustering for rows while preserving gaps
  dist_matrix <- stats::as.dist(1 - stats::cor(t(ordered_matrix), method = "pearson", use = "pairwise.complete.obs"))
  hc_rows <- stats::hclust(dist_matrix)

  # Define number of row clusters based on gaps
  num_clusters <- length(gaps_row) + 1


  # Define gradient color palette for correlation values, ensuring 0 is white
  heatmap_colors <- grDevices::colorRampPalette(c("lightblue", "white", "firebrick"))(100)

  # Define breakpoints so that the color gradient is centered at 0
  breaks <- seq(-1, 1, length.out = 101)  # Ensuring symmetric scaling

  # Generate heatmap
  heatmap <- pheatmap::pheatmap(
    ordered_matrix,
    cluster_rows = hc_rows,        # Perform clustering while preserving gaps
    cluster_cols = FALSE,          # Do not cluster columns
    cutree_rows = num_clusters,    # Cut tree at predefined cluster count
    show_colnames = FALSE,         # Hide column names
    gaps_row = gaps_row,           # Insert gaps between correlation groups
    color = heatmap_colors,        # Use continuous gradient for correlation values
    breaks = breaks,
    legend = TRUE,                 # Keep numerical correlation values in legend
    cellheight = 18,               # Set cell height for readability
    treeheight_row = 50,            # Show row dendrogram
    display_numbers = TRUE,
    number_color = "black"
  )
  return(heatmap)
}

# Function to return a list of correlation tables for the concepts
#' @keywords internal
computeConceptCorrelations <- function(data_patients, autoScaleRate = FALSE, abstractionLevel = -1, cohortDefinitionId = "target") {

  correlationResult = list()
  # Prepare the data: Convert to presence/absence or use actual prevalence
  data_binary <- data_patients %>%
    dplyr::filter(.data$ABSTRACTION_LEVEL == abstractionLevel, .data$COHORT_DEFINITION_ID == cohortDefinitionId) %>%
    dplyr::mutate(PRESENCE = ifelse(autoScaleRate, .data$PREVALENCE, 1)) %>%
    dplyr::select(.data$COHORT_DEFINITION_ID, .data$PERSON_ID, .data$ABSTRACTION_LEVEL, .data$CONCEPT_ID, .data$PRESENCE) %>%
    tidyr::pivot_wider(names_from = .data$CONCEPT_ID, values_from = .data$PRESENCE, values_fill = list(PRESENCE = 0))

  # Function to compute correlation matrices
  compute_correlation <- function(subset_data) {
    # Select only concept columns
    concept_data <- subset_data %>% dplyr::select(-c(.data$COHORT_DEFINITION_ID, .data$PERSON_ID, .data$ABSTRACTION_LEVEL))

    # Compute correlation matrix
    cor_matrix <- cor(concept_data, use = "pairwise.complete.obs")

    return(cor_matrix)
  }
  correlation_matrix <- compute_correlation(data_binary)

  correlationResult$correlation_matrix <- correlation_matrix
  correlationResult$map <- data_patients %>%
    dplyr::filter(.data$ABSTRACTION_LEVEL == abstractionLevel, .data$COHORT_DEFINITION_ID == cohortDefinitionId) %>%
    dplyr::select(.data$CONCEPT_ID, .data$CONCEPT_NAME, .data$HERITAGE) %>% dplyr::distinct() %>%
    dplyr::mutate(CONCEPT_ID = as.character(.data$CONCEPT_ID))
  correlationResult$map$CONCEPT_NAME <- unique_names(correlationResult$map$CONCEPT_NAME)

  return(correlationResult)
}


#' @keywords internal
unique_names <- function(names) {
  # Truncate names to 60 characters
  short_names <- stringr::str_sub(names, 1, 60)

  # Identify duplicated names
  duplicated_names <- duplicated(short_names) | duplicated(short_names, fromLast = TRUE)

  # Apply suffix only to duplicated names
  if (any(duplicated_names)) {
    counts <- ave(short_names[duplicated_names], short_names[duplicated_names], FUN = seq_along)
    short_names[duplicated_names] <- paste(short_names[duplicated_names], counts, sep = "_")
  }

  return(short_names)
}

