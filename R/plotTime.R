#' Generate a Time panel Plot
#'
#' This function generates a time panel plot using the CohortContrast GUI object.
#' It extracts necessary components from the ccObject and passes them to the
#' `createTimePlot` function to generate the plot.
#'
#' @param ccObject An object returned by the CohortContrast GUI, typically created
#'        when the "Create Visual Snapshot" button is pressed. It should contain
#'        target_row_annotation, target_col_annotation, target_time_annotation
#'        and target_matrix components.
#' @return A plot object generated by `createTimePlot`.
#' @examples
#' \dontrun{
#' # Assuming `ccObject` (visual snapshot) is already created via CohortContrast GUI
#' ccObject <- readRDS("./visual_snapshots/CohortContrastDataVisualSnapshot.rds")
#' getHeatmapPlot(ccObject)
#' }
#' @export
getTimePlot <- function(ccObject) {
  createTimePlot(
    ccObject$filtered_target
  )
}


#' @keywords internal
createTimePlot <- function(filtered_target, isCorrelationView = FALSE) {

  plot_data = getTimePlotData(filtered_target, isCorrelationView = isCorrelationView)

  # Check if any concepts left
  if (is.null(plot_data)) {
    return(getErrorPlot())
  }

  if (isCorrelationView) {
    return(getTimePlotCorrelation(plot_data))
  } else {
    return(getTimePlotRegular(plot_data))
  }
}

#' @keywords internal
getTimePlotData <- function(filtered_target, patientDataAllowed = TRUE, isCorrelationView = FALSE) {

  if (is.null(filtered_target) ||
      nrow(filtered_target$target_row_annotation) == 0) {
    return(NULL)
  }

  if (is.null(nrow(filtered_target$target_matrix))) {
    filtered_target$target_matrix <-
      t(as.matrix(filtered_target$target_matrix)[1:length(filtered_target$target_matrix), , drop = FALSE])
    rownames(filtered_target$target_matrix) <-
      rownames(filtered_target$target_row_annotation)
  }

  filtered_target$target_time_annotation <-
    as.data.frame(filtered_target$target_time_annotation)

  plotData <-
    filtered_target$target_time_annotation %>% dplyr::mutate(TIME_MEDIAN = sapply(.data$TIME_TO_EVENT, stats::median, na.rm = TRUE)) %>%
    dplyr::group_by(.data$CONCEPT_ID) %>%
    dplyr::summarise(
      CONCEPT_NAME = dplyr::first(.data$CONCEPT_NAME),
      # Taking the first instance assuming uniformity across the group
      HERITAGE = dplyr::first(.data$HERITAGE),
      # Similarly for HERITAGE
      TIME_TO_EVENT = list(unlist(.data$TIME_TO_EVENT)),
      TIME_MEDIAN = list(.data$TIME_MEDIAN),
      #KSTEST = dplyr::first(.data$KSTEST),
      # Similarly for KSTEST
      .groups = "drop"                     # Drop grouping information after summarising
    )


  if (isCorrelationView) {
    # Extract ordered data
    ordered_matrix <- filtered_target$correlation_analysis$ordered_matrix
    gaps_row <- filtered_target$correlation_analysis$gaps_row

    # Reorder plotData based on ordered_matrix row order
    ordered_indices <- match(rownames(ordered_matrix), plotData$CONCEPT_NAME)
    plotData <- plotData[ordered_indices, ]
    plotData$Group <- cut(seq_len(nrow(plotData)), breaks = c(0, gaps_row, nrow(plotData)), labels = FALSE)

    # Unnest TIME_TO_EVENT
    plotData <- plotData %>%
      dplyr::select(.data$CONCEPT_ID, .data$CONCEPT_NAME, .data$TIME_TO_EVENT, .data$Group) %>%
      tidyr::unnest(.data$TIME_TO_EVENT)  # Flatten TIME_TO_EVENT list

  } else {

    plotData = plotData %>% dplyr::select(.data$CONCEPT_ID,
                                          .data$CONCEPT_NAME,
                                          .data$TIME_TO_EVENT,
                                          .data$HERITAGE,
                                          #.data$KSTEST,
    ) %>% tidyr::unnest(.data$TIME_TO_EVENT)  # Make sure TIME_MEDIAN is no longer a list

    plotData$Group = 1
  }
  plotData$CONCEPT_ID = as.character(plotData$CONCEPT_ID)
  return(plotData)
}


#' @keywords internal
getTimePlotRegular <- function(plot_data) {
  heritage_colors <- getHeritageColors(asList = TRUE)

  time_min <- min(plot_data$TIME_TO_EVENT, na.rm = TRUE)
  time_max <- max(plot_data$TIME_TO_EVENT, na.rm = TRUE)

  # Compute median time for each concept within each heritage group
  concept_order <- plot_data %>%
    dplyr::group_by(HERITAGE, CONCEPT_NAME) %>%
    dplyr::summarise(median_time = stats::median(TIME_TO_EVENT, na.rm = TRUE), .groups = "drop") %>%
    dplyr::arrange(HERITAGE, median_time)  # Ensure ascending order

  # Convert CONCEPT_NAME into a factor, ordered in ascending median time within each HERITAGE
  plot_data <- plot_data %>%
    dplyr::mutate(CONCEPT_NAME = factor(CONCEPT_NAME,
                                        levels = rev(concept_order$CONCEPT_NAME)))  # Reverse levels for ascending order

  # Heritage text dataset
  heritage_annot <- plot_data %>%
    dplyr::group_by(.data$HERITAGE) %>%
    dplyr::arrange(.data$HERITAGE, dplyr::desc(as.numeric(.data$CONCEPT_NAME))) %>%
    dplyr::slice(1) %>%
    dplyr::select(.data$HERITAGE, .data$CONCEPT_NAME) %>%
    dplyr::ungroup()

  p <- ggplot2::ggplot(
    plot_data,
    ggplot2::aes(
      y = CONCEPT_NAME,
      x = .data$TIME_TO_EVENT,
      group = .data$CONCEPT_NAME
    )
  ) +
    # Add horizontal violin plot
    ggplot2::geom_violin(ggplot2::aes(fill = .data$HERITAGE), width = 1.2, color = NA, alpha = 0.5, trim = FALSE) +
    ggplot2::geom_text(ggplot2::aes(label = .data$HERITAGE), x = time_max, hjust = 1, size = 6, fontface = "bold", color = "navy", alpha = 0.5, data = heritage_annot) +
    ggplot2::geom_boxplot(fill = NA, outliers = FALSE, width = 0.3) +
    ggplot2::scale_fill_manual(values = heritage_colors) +
    # Faceting by HERITAGE
    ggplot2::facet_grid(.data$HERITAGE ~ ., scales = "free_y", space = "free") +
    ggplot2::scale_x_continuous(limit = c(time_min, time_max),
                                sec.axis = ggplot2::dup_axis(),
                                expand = ggplot2::expansion(mult = 0.01)) +
    # Enhance the plot appearance with a minimal theme
    ggplot2::theme_bw() +
    ggplot2::labs(title = "Event occurrences timing (days since index)",
                  x = "",
                  y = "") +
    ggplot2::theme(
      # Adjust y-axis text size
      legend.position = "none",
      # Hide legend as needed
      strip.background = ggplot2::element_blank(),
      # Clean up strip background
      strip.text.y = ggplot2::element_blank(),
      axis.text.y = ggplot2::element_text(size = 10),
      axis.title = ggplot2::element_blank(),
      # Hide strip text
      panel.spacing = ggplot2::unit(0.5, "lines")  # Reduce spacing between panels
    )

  return(p)
}

#' @keywords internal
getTimePlotCorrelation <- function(plot_data) {

  # Get time range
  time_min <- min(plot_data$TIME_TO_EVENT, na.rm = TRUE)
  time_max <- max(plot_data$TIME_TO_EVENT, na.rm = TRUE)
  # Compute median time for each concept within each group
  # Compute median time for each concept within each group
  concept_order <- plot_data %>%
    dplyr::group_by(Group, CONCEPT_NAME) %>%
    dplyr::summarise(median_time = stats::median(TIME_TO_EVENT, na.rm = TRUE), .groups = "drop") %>%
    dplyr::arrange(Group, median_time)  # Ensure ascending order

  # Create a combined ordering column for proper factor sorting
  concept_order <- concept_order %>%
    dplyr::mutate(ordering = paste0(Group, "-", CONCEPT_NAME))

  # Ensure factor levels respect the ordering per group
  plot_data <- plot_data %>%
    dplyr::left_join(concept_order, by = c("Group", "CONCEPT_NAME")) %>%
    dplyr::mutate(CONCEPT_NAME = forcats::fct_reorder(CONCEPT_NAME, median_time, .desc = TRUE))

  # Create a palette that repeats as needed for the number of groups
  num_groups <- length(unique(plot_data$Group))
  palette_colors <- RColorBrewer::brewer.pal(min(num_groups, 12), "Set3")
  palette_colors <- rep(palette_colors, length.out = num_groups)  # Repeat colors to match groups

  # Create the plot
  p <- ggplot2::ggplot(
    plot_data,
    ggplot2::aes(
      y = CONCEPT_NAME,
      x = TIME_TO_EVENT,
      group = CONCEPT_NAME,
      fill = factor(Group)
    )
  ) +
    ggplot2::geom_violin(width = 1.2, color = NA, alpha = 0.5, trim = FALSE) +
    ggplot2::geom_boxplot(fill = NA, outliers = FALSE, width = 0.3) +
    ggplot2::facet_grid(Group ~ ., scales = "free_y", space = "free") +
    ggplot2::scale_x_continuous(limits = c(time_min, time_max), sec.axis = ggplot2::dup_axis(), expand = ggplot2::expansion(mult = 0.01)) +
    ggplot2::scale_fill_manual(values = palette_colors) +
    ggplot2::theme_bw() +
    ggplot2::labs(title = "Event occurrences timing (days since index)", x = "", y = "") +
    ggplot2::theme(
      legend.position = "none",
      strip.background = ggplot2::element_blank(),
      strip.text.y = ggplot2::element_blank(),
      axis.text.y = ggplot2::element_text(size = 10),
      axis.title = ggplot2::element_blank(),
      panel.spacing = ggplot2::unit(0.5, "lines")
    )

  return(p)
}
