#' Generate a Time panel Plot
#'
#' This function generates a time panel plot using the CohortContrast GUI object.
#' It extracts necessary components from the ccObject and passes them to the
#' `createTimePlot` function to generate the plot.
#'
#' @param ccObject An object returned by the CohortContrast GUI, typically created
#'        when the "Create Visual Snapshot" button is pressed. It should contain
#'        target_row_annotation, target_col_annotation, target_time_annotation
#'        and target_matrix components.
#' @return A plot object generated by `createTimePlot`.
#' @examples
#' \dontrun{
#' # Assuming `ccObject` (visual snapshot) is already created via CohortContrast GUI
#' ccObject <- readRDS("./visual_snapshots/CohortContrastDataVisualSnapshot.rds")
#' getHeatmapPlot(ccObject)
#' }
#' @export
getTimePlot <- function(ccObject) {
  createTimePlot(
    ccObject$filtered_target
  )
}


#' @keywords internal
createTimePlot <- function(filtered_target, isCorrelationView = FALSE) {

  plot_data = getTimePlotData(filtered_target, isCorrelationView = isCorrelationView)

  # Check if any concepts left
  if (is.null(plot_data)) {
    return(getErrorPlot())
  }

  if (isCorrelationView) {
    return(getTimePlotCorrelation(plot_data))
  } else {
    return(getTimePlotRegular(plot_data))
  }
}

#' @keywords internal
getTimePlotData <- function(filtered_target, patientDataAllowed = TRUE, isCorrelationView = FALSE) {

  if (is.null(filtered_target) ||
      nrow(filtered_target$target_row_annotation) == 0) {
    return(NULL)
  }

  if (is.null(nrow(filtered_target$target_matrix))) {
    filtered_target$target_matrix <-
      t(as.matrix(filtered_target$target_matrix)[1:length(filtered_target$target_matrix), , drop = FALSE])
    rownames(filtered_target$target_matrix) <-
      rownames(filtered_target$target_row_annotation)
  }

  filtered_target$target_time_annotation <-
    as.data.frame(filtered_target$target_time_annotation)

  plotData <-
    filtered_target$target_time_annotation %>% dplyr::mutate(TIME_MEDIAN = sapply(.data$TIME_TO_EVENT, stats::median, na.rm = TRUE)) %>%
    dplyr::group_by(.data$CONCEPT_ID) %>%
    dplyr::summarise(
      CONCEPT_NAME = dplyr::first(.data$CONCEPT_NAME),
      # Taking the first instance assuming uniformity across the group
      HERITAGE = dplyr::first(.data$HERITAGE),
      # Similarly for HERITAGE
      TIME_TO_EVENT = list(unlist(.data$TIME_TO_EVENT)),
      TIME_MEDIAN = list(.data$TIME_MEDIAN),
      #KSTEST = dplyr::first(.data$KSTEST),
      # Similarly for KSTEST
      .groups = "drop"                     # Drop grouping information after summarising
    )


  if (isCorrelationView) {
    # Extract ordered data
    ordered_matrix <- filtered_target$correlation_analysis$ordered_matrix
    gaps_row <- filtered_target$correlation_analysis$gaps_row

    # Reorder plotData based on ordered_matrix row order
    ordered_indices <- match(rownames(ordered_matrix), plotData$CONCEPT_NAME)
    plotData <- plotData[ordered_indices, ]
    plotData$Group <- cut(seq_len(nrow(plotData)), breaks = c(0, gaps_row, nrow(plotData)), labels = FALSE)

    # Unnest TIME_TO_EVENT
    plotData <- plotData %>%
      dplyr::select(.data$CONCEPT_ID, .data$CONCEPT_NAME, .data$TIME_TO_EVENT, .data$Group) %>%
      tidyr::unnest(.data$TIME_TO_EVENT)  # Flatten TIME_TO_EVENT list

  } else {

    plotData = plotData %>% dplyr::select(.data$CONCEPT_ID,
                                          .data$CONCEPT_NAME,
                                          .data$TIME_TO_EVENT,
                                          .data$HERITAGE,
                                             #.data$KSTEST,
    ) %>% tidyr::unnest(.data$TIME_TO_EVENT)  # Make sure TIME_MEDIAN is no longer a list

    plotData$Group = 1
  }
  plotData$CONCEPT_ID = as.character(plotData$CONCEPT_ID)
  return(plotData)
}


#' @keywords internal
getTimePlotRegular <- function(plot_data) {


  heritage_colors <- getHeritageColors(asList = TRUE)

  time_min <- min(plot_data$TIME_TO_EVENT, na.rm = TRUE)
  time_max <- max(plot_data$TIME_TO_EVENT, na.rm = TRUE)
  # Heritage text dataset
  heritage_annot = plot_data %>%
    dplyr::mutate(CONCEPT_NAME = stringr::str_sub(.data$CONCEPT_NAME, 1, 60)) %>%
    dplyr::group_by(.data$HERITAGE) %>%
    dplyr::summarise(CONCEPT_NAME = max(.data$CONCEPT_NAME)) %>%
    dplyr::ungroup()

  p <-
    ggplot2::ggplot(
      plot_data,
      ggplot2::aes(
        y = stringr::str_sub(.data$CONCEPT_NAME, 1, 60),
        x = .data$TIME_TO_EVENT,
        group = .data$CONCEPT_NAME
      )
    ) +
    # Add horizontal violin plot
    ggplot2::geom_violin(ggplot2::aes(fill = .data$HERITAGE), width = 1.2, color = NA, alpha = 0.5, trim = FALSE) +
    ggplot2::geom_text(aes(label = .data$HERITAGE), x = time_max, hjust = 1, size = 6, fontface = "bold", color = "navy", alpha = 0.5, data = heritage_annot) +
    ggplot2::geom_boxplot(fill = NA, outliers = FALSE, width = 0.3) +
    ggplot2::scale_fill_manual(values = heritage_colors) +
    # Faceting by HERITAGE
    ggplot2::facet_grid(.data$HERITAGE ~ ., scales = "free_y", space = "free") +
    ggplot2::scale_x_continuous(limit = c(time_min, time_max),
                                sec.axis = ggplot2::dup_axis(),
                                expand = ggplot2::expansion(mult = 0.01)) +
    # Enhance the plot appearance with a minimal theme
    ggplot2::theme_bw() +
    ggplot2::labs(title = "Event occurrences timing (days since index)",
                  x = "",
                  y = "") +
    ggplot2::theme(
      # Adjust y-axis text size
      legend.position = "none",
      # Hide legend as needed
      strip.background = ggplot2::element_blank(),
      # Clean up strip background
      strip.text.y = ggplot2::element_blank(),
      axis.text.y = ggplot2::element_text(size = 10),
      axis.title = ggplot2::element_blank(),
      # Hide strip text
      panel.spacing = ggplot2::unit(0.5, "lines")  # Reduce spacing between panels
    )
  return(p)
}

#' @keywords internal
getTimePlotCorrelation <- function(plot_data) {

  # Get time range
  time_min <- min(plot_data$TIME_TO_EVENT, na.rm = TRUE)
  time_max <- max(plot_data$TIME_TO_EVENT, na.rm = TRUE)

  # Create a palette that repeats as needed for the number of groups
  num_groups <- length(unique(plot_data$Group))
  palette_colors <- RColorBrewer::brewer.pal(min(num_groups, 12), "Set3")
  palette_colors <- rep(palette_colors, length.out = num_groups)  # Repeat colors to match groups

  # Create the plot with repeated fill colors for groups
  p <- ggplot2::ggplot(
    plot_data,
    ggplot2::aes(
      y = stringr::str_sub(.data$CONCEPT_NAME, 1, 60),
      x = .data$TIME_TO_EVENT,
      group = .data$CONCEPT_NAME,
      fill = factor(.data$Group)  # Map Group to fill
    )
  ) +
    # Add horizontal violin plot
    ggplot2::geom_violin(
      width = 1.2,
      color = NA,
      alpha = 0.5,
      trim = FALSE
    ) +
    ggplot2::geom_boxplot(
      fill = NA,  # Keep boxplot borders
      outliers = FALSE,
      width = 0.3
    ) +
    # Faceting by Group
    ggplot2::facet_grid(
      .data$Group ~ .,
      scales = "free_y",
      space = "free"
    ) +
    ggplot2::scale_x_continuous(
      limits = c(time_min, time_max),
      sec.axis = ggplot2::dup_axis(),
      expand = ggplot2::expansion(mult = 0.01)
    ) +
    # Manually define fill colors for groups
    ggplot2::scale_fill_manual(values = palette_colors) +
    # Enhance the plot appearance with a minimal theme
    ggplot2::theme_bw() +
    ggplot2::labs(
      title = "Event occurrences timing (days since index)",
      x = "",
      y = ""
    ) +
    ggplot2::theme(
      legend.position = "none",
      strip.background = ggplot2::element_blank(),
      strip.text.y = ggplot2::element_blank(),
      axis.text.y = ggplot2::element_text(size = 10),
      axis.title = ggplot2::element_blank(),
      panel.spacing = ggplot2::unit(0.5, "lines")
    )

  return(p)
}
